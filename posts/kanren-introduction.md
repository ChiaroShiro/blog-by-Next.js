---
title: '逻辑编程库Kanren库浅析'
date: '2025-03-22'
tags: ['逻辑编程', 'AI', 'kanren', 'Python']
pinned: false
---

我似乎得了一种遇到学不会的知识就会自闭的病。

最近咱的电脑似乎不太愿意在跑了三小时Kanren后再跑cs2，于是就轻轻的把主板烧了以示抗议，离开了熟悉的生产环境咱的精神状况似乎更加不佳，在清醒与沉睡中度过一个下午后决定还是写写这篇鸽了好几天的文章，总之先做点事儿。

----

## 什么是Kanren库

一个早已停止维护的逻辑编程库，功能和效率十分之有限，可以被更新的 `MiniKanren` 替代。至于为什么不去尝试后者，可能需要去问问我的人工智能导论课老师。不过不论怎么说，把他拿来当一个简单的玩具还是问题不大的。

简而言之，你可以给这个库若干变量，再给出关于这些变量的若干限制条件，这个库可以求得满足这些条件下的解。

比如可以规定两个变量 ``a``, ``b``，随后再给出两个限制条件 ``a==b``, ``b==2``，随后让Kanren求出 ``a`` 所有的解，其输出就是 ``(2,)``

而代码也是比较浅显易懂的

```python
from kanren import *

a = var()
b = var()
print(run(0, a, eq(a, b), eq(b, 2)))
```

其中第一个变量的含义是输出解的个数，为0时表示输出所有可能解

## 使用Kanren库

在学习语法前，我们需要先解决版本问题，因为 Kanren 已经在 2018 年停止维护了，所以他不支持 ``Python 3.10`` 及以后的版本，想要在这些版本中使用 Kanren，需要手动修改 Kanren 库。

具体地，在 ``unification/core.py`` 和 ``kanren/utils.py`` 两个文件的第二行把 ``collections`` 换成 ``collections.abc`` 即可。

除了 ``eq(x, y)`` 这个功能很显然的函数外，还有些很有用的函数，比如 ``membero(x, S)`` 表示约束变量 ``x`` 属于集合 ``S``，``sub(x, y, n)`` 表示 ``x-y==n``，同理 ``add(x, y, n)``。

那为了更强的扩展性，我们可以用 ``lall(...)`` 函数合并很多需要同时成立的条件集，``lany(...)`` 函数合并需要成立至少一个的条件集。或者简单的说， ``lall`` 就是与运算，``lany`` 就是或运算，同时第二个参数传进去一个列表表示要对很多变量求解。

```python
from kanren import *
from kanren.arith import add, sub

def solution2():
    a = var()
    b = var()
    con = lall(membero(b, [1,2,3,4,5]), membero(a, [1,2,3,4,5]), sub(a, b, 1), add(a, b, 5))
    print(run(0, [a, b], con))
```

我们期望的输出是 ``([3, 2],)``，但是很失望的是程序直接报错

具体原因大体是因为 Kanren 库函数在求解时是同时推进 ``a`` 和 ``b`` 的推导，只有在确定下来其中一个变量的值之后才能进而确定其他所有变量的值，但是上述两个方程都没法先固定 ``a`` 的值或者 ``b`` 的值。

而且在旧版 Kanren 库下，很多函数都是缺失的，比如就没有约束 ``x!=y`` 这种条件的函数。

**这实在是太逊了**，那我们怎么办呢

## 自定义Kanren库

自定义 Kanren 函数还是比较容易的。

首先我们需要一个 ``walk(x, S)`` 函数

```python
def walk(u, s):
    while u in s:
        u = s[u]
    return u
```

其中 ``x`` 是个变量，``S`` 是一个字典，这个字典里面表明了变量之间的等价关系。比如在开头第一个例子中

```python
a = var()
b = var()
print(run(0, a, eq(a, b), eq(b, 2)))
```

这里面 ``a``, ``b`` 和 ``2`` 都是等价关系，求解 ``a`` 时就会用 ``walk`` 函数顺着这两个等值式找到最终的值 2。

换个视角讲，其实这就是一个类似于寻找高维指针最终指向的值的函数。

具体的自定义 Kanren 函数时，我们需要返回一个函数，返回的函数有一个参数 ``S``，含义和 ``walk`` 里是一样的。这里给出一个自己实现的 ``add(x, y, n)`` 函数，限制了 ``x+y==n`` 这个条件。

```python
def myadd (x, y, n):
    def goal(s):
        wx = walk(x, s)
        wy = walk(y, s)
        if isinstance(wx, int) and isinstance(wy, int):
            if wx + wy != n:
                return ()
        return (s,)
    return goal
```

首先我们要用 ``walk`` 找到两个变量的值，然后判断两者是否是 ``int`` 类型，如果两个变量还没有确定好具体的值时他们就不会是 ``int`` 类型，如果他们已经确定好值后就可以加以判断了。当不满足限制的时候需要返回一个空集表示不满足，而当满足条件或者两者还没有确定值时就要返回 ``(s,)``，表示满足条件。

拥有了自定义函数的能力，我们能做的事情就多了许多了，比如求解八皇后问题对吧。

最后不得不感叹一下 Kanren 感人的效率，咱实现的代码求解 $N=6$ 的六皇后就需要跑上好几秒，$N=7$ 时就需要足足两三分钟了，在来得及得到 $N=8$ 答案前我的电脑主板就已经烧了，虽然可能不关 Kanren 什么事，但是不得不说这个效率确实是挺逆天的。不过谴责 Kanren 似乎是没什么道理的，毕竟人家也只是 public 了一个玩具，但是拿这种东西出成作业题的人工智能导论课就有点难以饶恕了。